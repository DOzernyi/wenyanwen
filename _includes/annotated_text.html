<div class="annotated-container">
  <div class="footnote-filters" id="footnote-filters-{{ include.id | default: 'main' }}">
  </div>
  <div class="annotated-main" id="annotated-content-{{ include.id | default: 'main' }}">
    {{ include.content | markdownify }}
  </div>
  <div class="annotated-notes" id="annotated-notes-{{ include.id | default: 'main' }}">
  </div>
</div>
<script>
(function() {
  var containerId = '{{ include.id | default: "main" }}';
  var container = document.getElementById('annotated-content-' + containerId);
  var notesContainer = document.getElementById('annotated-notes-' + containerId);
  var filtersContainer = document.getElementById('footnote-filters-' + containerId);
  var annotatedContainer = container.parentElement;
  var refs = container.querySelectorAll('.note-ref[data-note-text]');
  var sidenotes = [];
  var labelCounters = {};
  var labelColors = {};
  var hiddenLabels = {};

  refs.forEach(function(ref) {
    var label = ref.getAttribute('data-note-label') || 'æ³¨';
    var text = ref.getAttribute('data-note-text');
    var color = ref.getAttribute('data-note-color') || '#267CB9';
    
    if (!labelCounters[label]) {
      labelCounters[label] = 0;
      labelColors[label] = color;
    }
    labelCounters[label]++;
    var numberedId = label + labelCounters[label];
    
    ref.textContent = numberedId;
    ref.setAttribute('data-note-id', numberedId);
    
    if (text) {
      var note = document.createElement('div');
      note.className = 'sidenote';
      note.setAttribute('data-label', label);
      note.style.borderLeftColor = color;
      note.innerHTML = '<span class="note-marker" style="background-color: ' + color + ';">' + numberedId + '</span> ' + text;
      notesContainer.appendChild(note);
      
      var parentP = ref.closest('p');
      sidenotes.push({ ref: ref, note: note, parentP: parentP, label: label });
    }
  });

  var labels = Object.keys(labelCounters);
  if (labels.length > 0) {
    labels.forEach(function(label) {
      var btn = document.createElement('button');
      btn.className = 'filter-btn active';
      btn.setAttribute('data-label', label);
      btn.style.borderColor = labelColors[label];
      btn.style.color = labelColors[label];
      btn.innerHTML = label + ' <span class="filter-count">' + labelCounters[label] + '</span>';
      
      btn.addEventListener('click', function() {
        var isActive = btn.classList.contains('active');
        if (isActive) {
          btn.classList.remove('active');
          btn.style.backgroundColor = '';
          btn.style.color = labelColors[label];
          hiddenLabels[label] = true;
        } else {
          btn.classList.add('active');
          btn.style.backgroundColor = '';
          btn.style.color = labelColors[label];
          delete hiddenLabels[label];
        }
        updateVisibility();
        setTimeout(positionSidenotes, 50);
      });
      
      filtersContainer.appendChild(btn);
    });
  }

  function updateVisibility() {
    sidenotes.forEach(function(item) {
      var isHidden = hiddenLabels[item.label];
      item.ref.style.display = isHidden ? 'none' : '';
      item.note.style.display = isHidden ? 'none' : '';
    });
  }

  function positionSidenotes() {
    var isMobile = window.innerWidth <= 768;

    var paragraphs = container.querySelectorAll('p');
    paragraphs.forEach(function(p) {
      p.style.marginBottom = '';
    });

    if (isMobile) {
      sidenotes.forEach(function(item) {
        if (!hiddenLabels[item.label]) {
          item.note.style.position = 'static';
          item.note.style.top = '';
        }
      });
      return;
    }

    sidenotes.forEach(function(item) {
      if (!hiddenLabels[item.label]) {
        item.note.style.position = 'absolute';
        item.note.style.left = '0';
        item.note.style.right = '0';
      }
    });

    var containerRect = annotatedContainer.getBoundingClientRect();

    var pArray = Array.prototype.slice.call(paragraphs);
    var pData = pArray.map(function(p) {
      var r = p.getBoundingClientRect();
      return {
        el: p,
        naturalTop: r.top - containerRect.top,
        naturalHeight: r.height,
        naturalBottom: r.bottom - containerRect.top
      };
    });

    var visibleNotes = sidenotes.filter(function(item) {
      return !hiddenLabels[item.label];
    });

    var noteData = visibleNotes.map(function(item) {
      var refRect = item.ref.getBoundingClientRect();
      var pIdx = item.parentP ? pArray.indexOf(item.parentP) : -1;
      return {
        item: item,
        refTop: refRect.top - containerRect.top,
        noteHeight: item.note.offsetHeight,
        pIdx: pIdx
      };
    });

    var cumulativeShift = 0;
    var noteCursor = 0;
    var margins = new Array(pData.length);
    for (var i = 0; i < margins.length; i++) margins[i] = 0;

    var notesByParagraph = {};
    noteData.forEach(function(nd) {
      var key = nd.pIdx >= 0 ? nd.pIdx : -1;
      if (!notesByParagraph[key]) notesByParagraph[key] = [];
      notesByParagraph[key].push(nd);
    });

    for (var pi = 0; pi < pData.length; pi++) {
      var pd = pData[pi];
      var pTop = pd.naturalTop + cumulativeShift;
      var pBottom = pd.naturalBottom + cumulativeShift;

      var pNotes = notesByParagraph[pi];
      if (!pNotes || pNotes.length === 0) continue;

      for (var ni = 0; ni < pNotes.length; ni++) {
        var nd = pNotes[ni];
        var desiredTop = nd.refTop + cumulativeShift;
        var placedTop = Math.max(desiredTop, noteCursor);
        nd.placedTop = placedTop;
        noteCursor = placedTop + nd.noteHeight + 8;
      }

      if (noteCursor > pBottom) {
        var extra = Math.ceil(noteCursor - pBottom);
        margins[pi] = extra;
        cumulativeShift += extra;
      }
    }

    var orphanNotes = notesByParagraph[-1];
    if (orphanNotes) {
      for (var oi = 0; oi < orphanNotes.length; oi++) {
        var nd = orphanNotes[oi];
        var desiredTop = nd.refTop + cumulativeShift;
        var placedTop = Math.max(desiredTop, noteCursor);
        nd.placedTop = placedTop;
        noteCursor = placedTop + nd.noteHeight + 8;
      }
    }

    for (var mi = 0; mi < margins.length; mi++) {
      if (margins[mi] > 0) {
        pData[mi].el.style.marginBottom = margins[mi] + 'px';
      }
    }

    noteData.forEach(function(nd) {
      if (nd.placedTop !== undefined) {
        nd.item.note.style.top = nd.placedTop + 'px';
      }
    });
  }

  setTimeout(positionSidenotes, 200);
  
  window.addEventListener('resize', function() {
    setTimeout(positionSidenotes, 200);
  });
  window.addEventListener('load', function() {
    setTimeout(positionSidenotes, 300);
  });
  if (document.fonts && document.fonts.ready) {
    document.fonts.ready.then(function() {
      setTimeout(positionSidenotes, 100);
    });
  }
})();
</script>
